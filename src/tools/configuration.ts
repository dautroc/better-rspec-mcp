import { Tool } from '@modelcontextprotocol/sdk/types.js';
import { KnowledgeBase } from '../knowledge/base.js';
import { GetConfigurationInputSchema } from '../types/index.js';

/**
 * RSpec Configuration Tools
 */
export class RSpecConfigurationTools {
  constructor(private knowledgeBase: KnowledgeBase) {}

  getToolDefinitions(): Tool[] {
    return [
      {
        name: 'get_rspec_configuration',
        description: 'Get RSpec configuration templates and setup guidance',
        inputSchema: {
          type: 'object',
          properties: {
            type: {
              type: 'string',
              enum: ['spec_helper', 'rails_helper', 'guardfile', 'gemfile', 'rspec_config'],
              description: 'Type of configuration to generate'
            },
            projectType: {
              type: 'string',
              enum: ['rails', 'ruby', 'gem'],
              default: 'rails',
              description: 'Type of Ruby project'
            },
            includeComments: {
              type: 'boolean',
              default: true,
              description: 'Whether to include explanatory comments'
            },
            features: {
              type: 'array',
              items: { type: 'string' },
              description: 'Additional features to include (e.g., "webmock", "vcr", "simplecov")'
            }
          },
          required: ['type']
        }
      }
    ];
  }

  canHandle(toolName: string): boolean {
    return toolName === 'get_rspec_configuration';
  }

  async handleTool(name: string, args: any): Promise<any> {
    if (name === 'get_rspec_configuration') {
      return this.getRSpecConfiguration(args);
    }
    throw new Error(`Unknown tool: ${name}`);
  }

  private async getRSpecConfiguration(args: any): Promise<any> {
    const input = GetConfigurationInputSchema.parse(args);
    
    // Check if we have a template in the knowledge base
    const existingTemplate = this.knowledgeBase.getConfigurationsByType(input.type)[0];
    
    let configContent: string;
    let explanation: string;
    
    if (existingTemplate) {
      configContent = existingTemplate.content;
      explanation = existingTemplate.description;
    } else {
      const generated = this.generateConfiguration(input);
      configContent = generated.content;
      explanation = generated.explanation;
    }
    
    const response = `# ${this.getConfigurationTitle(input.type)}

**Project Type:** ${input.projectType}
**Features:** ${input.features?.join(', ') || 'Standard setup'}

## Configuration

\`\`\`ruby
${configContent}
\`\`\`

## Explanation

${explanation}

## Installation Instructions

${this.getInstallationInstructions(input)}

## Better Specs Guidelines Applied

${this.getAppliedGuidelines(input.type)}

## Next Steps

${this.getNextSteps(input.type)}
`;

    return {
      content: [{
        type: 'text',
        text: response
      }]
    };
  }

  private generateConfiguration(input: any): { content: string; explanation: string } {
    switch (input.type) {
      case 'spec_helper':
        return this.generateSpecHelper(input);
      case 'rails_helper':
        return this.generateRailsHelper(input);
      case 'guardfile':
        return this.generateGuardfile(input);
      case 'gemfile':
        return this.generateGemfile(input);
      case 'rspec_config':
        return this.generateRSpecConfig(input);
      default:
        return {
          content: '# Configuration not available',
          explanation: 'This configuration type is not yet supported.'
        };
    }
  }

  private generateSpecHelper(input: any): { content: string; explanation: string } {
    const includeComments = input.includeComments;
    
    let content = '';
    
    if (includeComments) {
      content += `# This file was generated by the \`rspec --init\` command. Conventionally, all
# specs live under a \`spec\` directory, which RSpec adds to the \`$LOAD_PATH\`.
# The generated \`.rspec\` file contains \`--require spec_helper\` which will cause
# this file to always be loaded, without a need to explicitly require it in any
# files.

`;
    }

    // Add SimpleCov if requested
    if (input.features?.includes('simplecov')) {
      content += `# Coverage reporting
require 'simplecov'
SimpleCov.start${input.projectType === 'rails' ? " 'rails'" : ''} do
  add_filter '/spec/'
  add_filter '/vendor/'
  minimum_coverage 80
end

`;
    }

    content += `RSpec.configure do |config|
  ${includeComments ? '# Use expect syntax only (no should)' : ''}
  config.expect_with :rspec do |expectations|
    ${includeComments ? '# This option will default to \`true\` in RSpec 4.' : ''}
    expectations.syntax = :expect
    ${includeComments ? '# This option makes the \`description\` and \`failure_message\` of custom matchers' : ''}
    ${includeComments ? '# include text for helper methods defined using \`chain\`' : ''}
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  ${includeComments ? '# rspec-mocks config goes here' : ''}
  config.mock_with :rspec do |mocks|
    ${includeComments ? '# Prevents you from mocking or stubbing a method that does not exist on' : ''}
    ${includeComments ? '# a real object. This is generally recommended.' : ''}
    mocks.verify_partial_doubles = true
  end

  ${includeComments ? '# This option will default to \`:apply_to_host_groups\` in RSpec 4' : ''}
  config.shared_context_metadata_behavior = :apply_to_host_groups

  ${includeComments ? '# Run specs in random order to surface order dependencies' : ''}
  config.order = :random
  Kernel.srand config.seed

  ${includeComments ? '# Disable monkey patching' : ''}
  config.disable_monkey_patching!

  ${includeComments ? '# Enable flags like --only-failures and --next-failure' : ''}
  config.example_status_persistence_file_path = ".rspec_status"

  ${includeComments ? '# Limit to one failure for fast feedback during development' : ''}
  config.fail_fast = 1

  ${includeComments ? '# Use documentation format when running a single file' : ''}
  config.default_formatter = 'doc' if config.files_to_run.one?

  ${includeComments ? '# Print the slowest examples' : ''}
  config.profile_examples = 10
end`;

    const explanation = `This spec_helper.rb configuration follows Better Specs guidelines:

- **Expect syntax only**: Enforces modern expect syntax and disables deprecated should syntax
- **Random order**: Runs tests in random order to catch order dependencies
- **Monkey patching disabled**: Prevents RSpec from modifying core Ruby classes
- **Strict mocking**: Enables verification of partial doubles to catch mocking errors
- **Fast feedback**: Configured for quick development cycles with fail_fast and status persistence
- **Documentation format**: Uses readable output format for single file runs
- **Performance profiling**: Shows slowest examples to help optimize test suite`;

    return { content, explanation };
  }

  private generateRailsHelper(input: any): { content: string; explanation: string } {
    const includeComments = input.includeComments;
    
    let content = `${includeComments ? '# This file is copied to spec/ when you run \'rails generate rspec:install\'' : ''}
require 'spec_helper'
ENV['RAILS_ENV'] ||= 'test'
require_relative '../config/environment'

${includeComments ? '# Prevent database truncation if the environment is production' : ''}
abort("The Rails environment is running in production mode!") if Rails.env.production?

require 'rspec/rails'

${includeComments ? '# Add additional requires below this line. Rails is not loaded until this point!' : ''}`;

    // Add feature-specific requires
    if (input.features?.includes('capybara')) {
      content += `\nrequire 'capybara/rails'`;
    }
    if (input.features?.includes('webmock')) {
      content += `\nrequire 'webmock/rspec'`;
    }
    if (input.features?.includes('vcr')) {
      content += `\nrequire 'vcr'`;
    }

    content += `

${includeComments ? '# Requires supporting ruby files with custom matchers and macros, etc,' : ''}
${includeComments ? '# in spec/support/ and its subdirectories.' : ''}
Dir[Rails.root.join('spec', 'support', '**', '*.rb')].sort.each { |f| require f }

${includeComments ? '# Checks for pending migrations and applies them before tests are run.' : ''}
begin
  ActiveRecord::Migration.maintain_test_schema!
rescue ActiveRecord::PendingMigrationError => e
  abort e.to_s.strip
end

RSpec.configure do |config|
  ${includeComments ? '# Remove this line if you\'re not using ActiveRecord or ActiveRecord fixtures' : ''}
  config.fixture_path = "\#{::Rails.root}/spec/fixtures"

  ${includeComments ? '# Use transactional fixtures for faster tests' : ''}
  config.use_transactional_fixtures = true

  ${includeComments ? '# RSpec Rails can automatically mix in different behaviours to your tests' : ''}
  ${includeComments ? '# based on their file location' : ''}
  config.infer_spec_type_from_file_location!

  ${includeComments ? '# Filter lines from Rails gems in backtraces.' : ''}
  config.filter_rails_from_backtrace!`;

    // Add FactoryBot configuration
    content += `

  ${includeComments ? '# Include FactoryBot methods' : ''}
  config.include FactoryBot::Syntax::Methods`;

    // Add authentication helpers
    if (input.features?.includes('devise')) {
      content += `

  ${includeComments ? '# Include Devise test helpers' : ''}
  config.include Devise::Test::ControllerHelpers, type: :controller
  config.include Devise::Test::IntegrationHelpers, type: :request`;
    }

    // Add database cleaner configuration
    if (input.features?.includes('database_cleaner')) {
      content += `

  ${includeComments ? '# Database Cleaner configuration' : ''}
  config.before(:suite) do
    DatabaseCleaner.strategy = :transaction
    DatabaseCleaner.clean_with(:truncation)
  end

  config.around(:each) do |example|
    DatabaseCleaner.cleaning do
      example.run
    end
  end`;
    }

    content += `
end`;

    // Add WebMock configuration
    if (input.features?.includes('webmock')) {
      content += `

${includeComments ? '# WebMock configuration' : ''}
WebMock.disable_net_connect!(allow_localhost: true)`;
    }

    // Add VCR configuration
    if (input.features?.includes('vcr')) {
      content += `

${includeComments ? '# VCR configuration' : ''}
VCR.configure do |config|
  config.cassette_library_dir = 'spec/vcr_cassettes'
  config.hook_into :webmock
  config.configure_rspec_metadata!
  config.allow_http_connections_when_no_cassette = false
end`;
    }

    const explanation = `This rails_helper.rb configuration provides a complete Rails testing setup:

- **Environment safety**: Prevents running tests in production
- **Transactional fixtures**: Uses database transactions for fast test isolation
- **Automatic spec types**: Infers spec types based on file location
- **FactoryBot integration**: Includes FactoryBot methods for easy test data creation
- **Support file loading**: Automatically loads all files from spec/support/
- **Migration checks**: Ensures database schema is up to date before running tests
- **Clean backtraces**: Filters Rails gem lines from error backtraces for clarity`;

    return { content, explanation };
  }

  private generateGuardfile(input: any): { content: string; explanation: string } {
    const includeComments = input.includeComments;
    
    const content = `${includeComments ? '# A sample Guardfile for RSpec' : ''}
${includeComments ? '# More info at https://github.com/guard/guard#readme' : ''}

guard :rspec, cmd: "bundle exec rspec" do
  require "guard/rspec/dsl"
  dsl = Guard::RSpec::Dsl.new(self)

  ${includeComments ? '# Feel free to open issues for suggestions and improvements' : ''}

  ${includeComments ? '# RSpec files' : ''}
  rspec = dsl.rspec
  watch(rspec.spec_helper) { rspec.spec_dir }
  watch(rspec.spec_support) { rspec.spec_dir }
  watch(rspec.spec_files)

  ${includeComments ? '# Ruby files' : ''}
  ruby = dsl.ruby
  dsl.watch_spec_files_for(ruby.lib_files)

  ${includeComments ? '# Rails files' : ''}
  rails = dsl.rails(view_extensions: %w(erb haml slim))
  dsl.watch_spec_files_for(rails.app_files)
  dsl.watch_spec_files_for(rails.views)

  watch(rails.controllers) do |m|
    [
      rspec.spec.call("routing/\#{m[1]}_routing"),
      rspec.spec.call("controllers/\#{m[1]}_controller"),
      rspec.spec.call("requests/\#{m[1]}")
    ]
  end

  ${includeComments ? '# Rails config changes' : ''}
  watch(rails.spec_helper)     { rspec.spec_dir }
  watch(rails.routes)          { "\#{rspec.spec_dir}/routing" }
  watch(rails.app_controller)  { "\#{rspec.spec_dir}/controllers" }

  ${includeComments ? '# Capybara features specs' : ''}
  watch(rails.view_dirs)     { |m| rspec.spec.call("features/\#{m[1]}") }
  watch(rails.layouts)       { rspec.spec.call("features") }

  ${includeComments ? '# Turnip features and steps' : ''}
  watch(%r{^spec/acceptance/(.+)\\.feature$})
  watch(%r{^spec/acceptance/steps/(.+)_steps\\.rb$}) do |m|
    Dir[File.join("**/\#{m[1]}.feature")][0] || "spec/acceptance"
  end
end`;

    const explanation = `This Guardfile provides intelligent test automation:

- **Automatic test running**: Runs relevant specs when files change
- **Smart file mapping**: Maps application files to their corresponding specs
- **Rails integration**: Handles Rails-specific file types and patterns
- **View specs**: Automatically runs feature specs when views change
- **Configuration watching**: Re-runs all specs when spec_helper changes
- **Routing specs**: Runs routing specs when controllers or routes change`;

    return { content, explanation };
  }

  private generateGemfile(input: any): { content: string; explanation: string } {
    const includeComments = input.includeComments;
    
    let content = `${includeComments ? '# Testing gems for Better RSpec setup' : ''}

group :development, :test do
  gem 'rspec-rails'
  gem 'factory_bot_rails'
  gem 'faker'
  gem 'pry-byebug'${includeComments ? ' # Debugging' : ''}
end

group :test do`;

    // Core testing gems
    if (input.features?.includes('capybara')) {
      content += `\n  gem 'capybara'${includeComments ? ' # System testing' : ''}`;
      content += `\n  gem 'selenium-webdriver'${includeComments ? ' # Browser automation' : ''}`;
    }

    if (input.features?.includes('webmock')) {
      content += `\n  gem 'webmock'${includeComments ? ' # HTTP request stubbing' : ''}`;
    }

    if (input.features?.includes('vcr')) {
      content += `\n  gem 'vcr'${includeComments ? ' # HTTP interaction recording' : ''}`;
    }

    if (input.features?.includes('simplecov')) {
      content += `\n  gem 'simplecov', require: false${includeComments ? ' # Coverage reporting' : ''}`;
    }

    if (input.features?.includes('database_cleaner')) {
      content += `\n  gem 'database_cleaner-active_record'${includeComments ? ' # Database cleaning' : ''}`;
    }

    if (input.features?.includes('shoulda_matchers')) {
      content += `\n  gem 'shoulda-matchers'${includeComments ? ' # Additional matchers' : ''}`;
    }

    content += `\n  gem 'timecop'${includeComments ? ' # Time manipulation for tests' : ''}`;

    content += `\nend

group :development do
  gem 'guard-rspec'${includeComments ? ' # Automatic test running' : ''}`;

    if (input.features?.includes('fuubar')) {
      content += `\n  gem 'fuubar'${includeComments ? ' # Better progress formatter' : ''}`;
    }

    content += `\nend`;

    const explanation = `This Gemfile includes essential gems for Better RSpec testing:

**Development & Test:**
- **rspec-rails**: Core RSpec integration for Rails
- **factory_bot_rails**: Test data factories following Better Specs guidelines
- **faker**: Realistic fake data generation
- **pry-byebug**: Debugging support for test development

**Test Only:**
- **capybara & selenium-webdriver**: System testing for user interactions
- **webmock**: HTTP request stubbing for external API testing
- **vcr**: Recording real HTTP interactions for reliable tests
- **simplecov**: Code coverage reporting
- **database_cleaner**: Reliable database state management
- **shoulda-matchers**: Expressive matchers for common Rails patterns
- **timecop**: Time manipulation for time-dependent tests

**Development:**
- **guard-rspec**: Automatic test running on file changes
- **fuubar**: Improved progress bar formatter`;

    return { content, explanation };
  }

  private generateRSpecConfig(input: any): { content: string; explanation: string } {
    const includeComments = input.includeComments;
    
    const content = `${includeComments ? '# .rspec configuration file' : ''}
--require spec_helper
--format documentation
--color
--fail-fast
--order random${includeComments ? '\n# --profile 10  # Uncomment to show slowest examples' : ''}`;

    const explanation = `This .rspec configuration follows Better Specs guidelines:

- **--require spec_helper**: Automatically loads spec_helper.rb
- **--format documentation**: Uses readable documentation format
- **--color**: Enables colored output for better readability
- **--fail-fast**: Stops on first failure for quick feedback during development
- **--order random**: Runs tests in random order to catch order dependencies
- **--profile**: Optional profiling to identify slow tests`;

    return { content, explanation };
  }

  private getConfigurationTitle(type: string): string {
    const titles: Record<string, string> = {
      'spec_helper': 'RSpec Spec Helper Configuration',
      'rails_helper': 'Rails Helper Configuration',
      'guardfile': 'Guard Configuration for Automatic Testing',
      'gemfile': 'Gemfile Testing Dependencies',
      'rspec_config': 'RSpec Configuration File (.rspec)'
    };
    return titles[type] || 'RSpec Configuration';
  }

  private getInstallationInstructions(input: any): string {
    switch (input.type) {
      case 'spec_helper':
        return `1. Save as \`spec/spec_helper.rb\`
2. Run \`rspec --init\` if you haven't already
3. Customize based on your project needs`;

      case 'rails_helper':
        return `1. Save as \`spec/rails_helper.rb\`
2. Install required gems: \`bundle install\`
3. Run \`rails generate rspec:install\` if not done already
4. Create \`spec/support/\` directory for support files`;

      case 'guardfile':
        return `1. Save as \`Guardfile\` in project root
2. Install guard: \`gem install guard guard-rspec\`
3. Run \`bundle exec guard\` to start automatic testing
4. Customize file watching patterns as needed`;

      case 'gemfile':
        return `1. Add these gems to your existing Gemfile
2. Run \`bundle install\`
3. Configure each gem as needed in spec helpers
4. Run \`rails generate rspec:install\` for Rails projects`;

      case 'rspec_config':
        return `1. Save as \`.rspec\` in project root
2. Customize options based on your preferences
3. Run \`rspec\` to test the configuration
4. Add \`--profile\` to identify slow tests`;

      default:
        return 'Follow the standard installation process for this configuration type.';
    }
  }

  private getAppliedGuidelines(type: string): string {
    const commonGuidelines = [
      '✅ **Modern syntax**: Enforces expect syntax over deprecated should',
      '✅ **Random order**: Prevents order-dependent test failures',
      '✅ **Fast feedback**: Configured for quick development cycles'
    ];

    const typeSpecificGuidelines: Record<string, string[]> = {
      'spec_helper': [
        '✅ **Strict configuration**: Disables monkey patching for cleaner tests',
        '✅ **Performance profiling**: Identifies slow tests for optimization',
        '✅ **Failure isolation**: Fail-fast for immediate feedback'
      ],
      'rails_helper': [
        '✅ **Transactional fixtures**: Fast database isolation',
        '✅ **FactoryBot integration**: Better test data management',
        '✅ **Support file loading**: Organized test helpers and shared examples'
      ],
      'guardfile': [
        '✅ **Continuous testing**: Automatic test execution on file changes',
        '✅ **Smart mapping**: Runs relevant tests based on changed files',
        '✅ **Rails awareness**: Handles Rails-specific file patterns'
      ],
      'gemfile': [
        '✅ **Essential tools**: Includes all recommended testing gems',
        '✅ **Proper grouping**: Separates development and test dependencies',
        '✅ **Better Specs alignment**: All gems support Better Specs practices'
      ],
      'rspec_config': [
        '✅ **Documentation format**: Readable test output',
        '✅ **Colored output**: Better visual feedback',
        '✅ **Random execution**: Catches test order dependencies'
      ]
    };

    const guidelines = [...commonGuidelines, ...(typeSpecificGuidelines[type] || [])];
    return guidelines.join('\n');
  }

  private getNextSteps(type: string): string {
    switch (type) {
      case 'spec_helper':
        return `1. Set up Rails helper if using Rails
2. Create spec/support/ directory for shared examples
3. Configure additional gems (SimpleCov, WebMock, etc.)
4. Write your first spec following Better Specs guidelines`;

      case 'rails_helper':
        return `1. Create spec/support/ files for shared examples and helpers
2. Set up FactoryBot factories in spec/factories/
3. Configure Capybara for system tests
4. Add custom matchers if needed`;

      case 'guardfile':
        return `1. Start Guard with \`bundle exec guard\`
2. Customize file watching patterns for your project
3. Add notifications (terminal-notifier, libnotify, etc.)
4. Configure Guard with your preferred test runner options`;

      case 'gemfile':
        return `1. Run \`bundle install\` to install gems
2. Configure each gem in your spec helpers
3. Set up FactoryBot factories
4. Configure Capybara for system testing`;

      case 'rspec_config':
        return `1. Test the configuration with \`rspec\`
2. Adjust options based on your workflow
3. Add project-specific options as needed
4. Consider adding custom formatters`;

      default:
        return 'Continue with your RSpec setup and start writing tests!';
    }
  }
}
